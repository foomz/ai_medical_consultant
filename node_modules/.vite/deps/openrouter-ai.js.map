{
  "version": 3,
  "sources": ["../../eventsource-parser/src/parse.ts", "../../openrouter-ai/node_modules/nanoid/non-secure/index.js", "../../openrouter-ai/dist/index.mjs"],
  "sourcesContent": ["/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n *\n * Based on code from the {@link https://github.com/EventSource/eventsource | EventSource module},\n * which is licensed under the MIT license. And copyrighted the EventSource GitHub organisation.\n */\nimport type {EventSourceParseCallback, EventSourceParser} from './types.js'\n\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(onParse: EventSourceParseCallback): EventSourceParser {\n  // Processing state\n  let isFirstChunk: boolean\n  let buffer: string\n  let startingPosition: number\n  let startingFieldLength: number\n\n  // Event state\n  let eventId: string | undefined\n  let eventName: string | undefined\n  let data: string\n\n  reset()\n  return {feed, reset}\n\n  function reset(): void {\n    isFirstChunk = true\n    buffer = ''\n    startingPosition = 0\n    startingFieldLength = -1\n\n    eventId = undefined\n    eventName = undefined\n    data = ''\n  }\n\n  function feed(chunk: string): void {\n    buffer = buffer ? buffer + chunk : chunk\n\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n    // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n    // always decoded as UTF8 as per the specification.\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length)\n    }\n\n    isFirstChunk = false\n\n    // Set up chunk-specific processing state\n    const length = buffer.length\n    let position = 0\n    let discardTrailingNewline = false\n\n    // Read the current buffer byte by byte\n    while (position < length) {\n      // EventSource allows for carriage return + line feed, which means we\n      // need to ignore a linefeed character if the previous character was a\n      // carriage return\n      // @todo refactor to reduce nesting, consider checking previous byte?\n      // @todo but consider multiple chunks etc\n      if (discardTrailingNewline) {\n        if (buffer[position] === '\\n') {\n          ++position\n        }\n        discardTrailingNewline = false\n      }\n\n      let lineLength = -1\n      let fieldLength = startingFieldLength\n      let character: string\n\n      for (let index = startingPosition; lineLength < 0 && index < length; ++index) {\n        character = buffer[index]\n        if (character === ':' && fieldLength < 0) {\n          fieldLength = index - position\n        } else if (character === '\\r') {\n          discardTrailingNewline = true\n          lineLength = index - position\n        } else if (character === '\\n') {\n          lineLength = index - position\n        }\n      }\n\n      if (lineLength < 0) {\n        startingPosition = length - position\n        startingFieldLength = fieldLength\n        break\n      } else {\n        startingPosition = 0\n        startingFieldLength = -1\n      }\n\n      parseEventStreamLine(buffer, position, fieldLength, lineLength)\n\n      position += lineLength + 1\n    }\n\n    if (position === length) {\n      // If we consumed the entire buffer to read the event, reset the buffer\n      buffer = ''\n    } else if (position > 0) {\n      // If there are bytes left to process, set the buffer to the unprocessed\n      // portion of the buffer only\n      buffer = buffer.slice(position)\n    }\n  }\n\n  function parseEventStreamLine(\n    lineBuffer: string,\n    index: number,\n    fieldLength: number,\n    lineLength: number\n  ) {\n    if (lineLength === 0) {\n      // We reached the last line of this event\n      if (data.length > 0) {\n        onParse({\n          type: 'event',\n          id: eventId,\n          event: eventName || undefined,\n          data: data.slice(0, -1), // remove trailing newline\n        })\n\n        data = ''\n        eventId = undefined\n      }\n      eventName = undefined\n      return\n    }\n\n    const noValue = fieldLength < 0\n    const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength))\n    let step = 0\n\n    if (noValue) {\n      step = lineLength\n    } else if (lineBuffer[index + fieldLength + 1] === ' ') {\n      step = fieldLength + 2\n    } else {\n      step = fieldLength + 1\n    }\n\n    const position = index + step\n    const valueLength = lineLength - step\n    const value = lineBuffer.slice(position, position + valueLength).toString()\n\n    if (field === 'data') {\n      data += value ? `${value}\\n` : '\\n'\n    } else if (field === 'event') {\n      eventName = value\n    } else if (field === 'id' && !value.includes('\\u0000')) {\n      eventId = value\n    } else if (field === 'retry') {\n      const retry = parseInt(value, 10)\n      if (!Number.isNaN(retry)) {\n        onParse({type: 'reconnect-interval', value: retry})\n      }\n    }\n  }\n}\n\nconst BOM = [239, 187, 191]\n\nfunction hasBom(buffer: string) {\n  return BOM.every((charCode: number, index: number) => buffer.charCodeAt(index) === charCode)\n}\n", "let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n", "var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// streams/ai-stream.ts\nimport {\n  createParser\n} from \"eventsource-parser\";\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    start(controller) {\n      return __async(this, null, function* () {\n        eventSourceParser = createParser(\n          (event) => {\n            if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\") {\n              controller.terminate();\n              return;\n            }\n            if (\"data\" in event) {\n              const parsedMessage = customParser(event.data);\n              if (parsedMessage)\n                controller.enqueue(parsedMessage);\n            }\n          }\n        );\n      });\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const { onStart, onToken, onCompletion } = callbacks || {};\n  return new TransformStream({\n    start() {\n      return __async(this, null, function* () {\n        if (onStart)\n          yield onStart();\n      });\n    },\n    transform(message, controller) {\n      return __async(this, null, function* () {\n        controller.enqueue(textEncoder.encode(message));\n        if (onToken)\n          yield onToken(message);\n        if (onCompletion)\n          aggregatedResponse += message;\n      });\n    },\n    flush() {\n      return __async(this, null, function* () {\n        if (onCompletion)\n          yield onCompletion(aggregatedResponse);\n      });\n    }\n  });\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      let _a;\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        start(controller) {\n          return __async(this, null, function* () {\n            const { done, value } = yield reader.read();\n            if (!done) {\n              const errorText = new TextDecoder().decode(value);\n              controller.error(new Error(`Response error: ${errorText}`));\n            }\n          });\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\n\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (data) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;\n    const json = JSON.parse(data);\n    if ((_c = (_b = (_a = json.choices[0]) == null ? void 0 : _a.delta) == null ? void 0 : _b.function_call) == null ? void 0 : _c.name) {\n      isFunctionStreamingIn = true;\n      return `{\"function_call\": {\"name\": \"${(_e = (_d = json.choices[0]) == null ? void 0 : _d.delta) == null ? void 0 : _e.function_call.name}\", \"arguments\": \"`;\n    } else if ((_h = (_g = (_f = json.choices[0]) == null ? void 0 : _f.delta) == null ? void 0 : _g.function_call) == null ? void 0 : _h.arguments) {\n      const argumentChunk = json.choices[0].delta.function_call.arguments;\n      let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n      return `${escapedPartialJson}`;\n    } else if ((((_i = json.choices[0]) == null ? void 0 : _i.finish_reason) === \"function_call\" || ((_j = json.choices[0]) == null ? void 0 : _j.finish_reason) === \"stop\") && isFunctionStreamingIn) {\n      isFunctionStreamingIn = false;\n      return '\"}}';\n    }\n    const text = trimStartOfStream(\n      (_o = (_n = (_l = (_k = json.choices[0]) == null ? void 0 : _k.delta) == null ? void 0 : _l.content) != null ? _n : (_m = json.choices[0]) == null ? void 0 : _m.text) != null ? _o : \"\"\n    );\n    return text;\n  };\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  const stream = AIStream(res, parseOpenAIStream(), cb);\n  if (cb && cb.experimental_onFunctionCall) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream;\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  return new TransformStream({\n    transform(chunk, controller) {\n      return __async(this, null, function* () {\n        const message = new TextDecoder().decode(chunk);\n        const shouldHandleAsFunction = isFirstChunk && message.startsWith('{\"function_call\":');\n        if (shouldHandleAsFunction) {\n          isFunctionStreamingIn = true;\n          aggregatedResponse += message;\n          isFirstChunk = false;\n          return;\n        }\n        if (!isFunctionStreamingIn) {\n          controller.enqueue(chunk);\n          return;\n        } else {\n          aggregatedResponse += message;\n        }\n      });\n    },\n    flush(controller) {\n      return __async(this, null, function* () {\n        const isEndOfFunction = !isFirstChunk && callbacks.experimental_onFunctionCall && isFunctionStreamingIn;\n        if (isEndOfFunction && callbacks.experimental_onFunctionCall) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          const argumentsPayload = JSON.parse(payload.function_call.arguments);\n          let newFunctionCallMessages = [...functionCallMessages];\n          const functionResponse = yield callbacks.experimental_onFunctionCall(\n            {\n              name: payload.function_call.name,\n              arguments: argumentsPayload\n            },\n            (result) => {\n              newFunctionCallMessages = [\n                ...functionCallMessages,\n                {\n                  role: \"assistant\",\n                  content: \"\",\n                  function_call: payload.function_call\n                },\n                {\n                  role: \"function\",\n                  name: payload.function_call.name,\n                  content: JSON.stringify(result)\n                }\n              ];\n              return newFunctionCallMessages;\n            }\n          );\n          if (!functionResponse) {\n            controller.enqueue(textEncoder.encode(aggregatedResponse));\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(textEncoder.encode(functionResponse));\n            return;\n          }\n          const filteredCallbacks = __spreadProps(__spreadValues({}, callbacks), {\n            onStart: void 0,\n            onCompletion: void 0\n          });\n          const openAIStream = OpenAIStream(functionResponse, __spreadProps(__spreadValues({}, filteredCallbacks), {\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          }));\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = yield reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      });\n    }\n  });\n}\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init) {\n    super(res, __spreadProps(__spreadValues({}, init), {\n      status: 200,\n      headers: __spreadValues({\n        \"Content-Type\": \"text/plain; charset=utf-8\"\n      }, init == null ? void 0 : init.headers)\n    }));\n  }\n};\nfunction streamToResponse(res, response, init) {\n  response.writeHead((init == null ? void 0 : init.status) || 200, __spreadValues({\n    \"Content-Type\": \"text/plain; charset=utf-8\"\n  }, init == null ? void 0 : init.headers));\n  const reader = res.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n// streams/huggingface-stream.ts\nfunction createParser2(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    pull(controller) {\n      return __async(this, null, function* () {\n        var _a2, _b;\n        const { value, done } = yield res.next();\n        if (done) {\n          controller.close();\n          return;\n        }\n        const text = trimStartOfStream((_b = (_a2 = value.token) == null ? void 0 : _a2.text) != null ? _b : \"\");\n        if (!text)\n          return;\n        if (value.generated_text != null && value.generated_text.length > 0) {\n          controller.close();\n          return;\n        }\n        if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n          controller.close();\n        } else {\n          controller.enqueue(text);\n        }\n      });\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser2(res).pipeThrough(createCallbacksTransformer(callbacks));\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nfunction processLines(lines, controller) {\n  return __async(this, null, function* () {\n    for (const line of lines) {\n      const { text, is_finished } = JSON.parse(line);\n      if (is_finished === true) {\n        controller.close();\n      } else {\n        controller.enqueue(text);\n      }\n    }\n  });\n}\nfunction readAndProcessLines(reader, controller) {\n  return __async(this, null, function* () {\n    let segment = \"\";\n    while (true) {\n      const { value: chunk, done } = yield reader.read();\n      if (done) {\n        break;\n      }\n      segment += utf8Decoder.decode(chunk, { stream: true });\n      const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n      segment = linesArray.pop() || \"\";\n      yield processLines(linesArray, controller);\n    }\n    if (segment) {\n      const linesArray = [segment];\n      yield processLines(linesArray, controller);\n    }\n    controller.close();\n  });\n}\nfunction createParser3(res) {\n  var _a;\n  const reader = (_a = res.body) == null ? void 0 : _a.getReader();\n  return new ReadableStream({\n    start(controller) {\n      return __async(this, null, function* () {\n        if (!reader) {\n          controller.close();\n          return;\n        }\n        yield readAndProcessLines(reader, controller);\n      });\n    }\n  });\n}\nfunction CohereStream(reader, callbacks) {\n  return createParser3(reader).pipeThrough(createCallbacksTransformer(callbacks));\n}\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    const text = json.completion;\n    const delta = text.slice(previous.length);\n    previous = text;\n    return delta;\n  };\n}\nfunction AnthropicStream(res, cb) {\n  return AIStream(res, parseAnthropicStream(), cb);\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = (e, runId) => __async(this, null, function* () {\n    runs.delete(runId);\n    yield writer.ready;\n    yield writer.abort(e);\n  });\n  const handleStart = (runId) => __async(this, null, function* () {\n    runs.add(runId);\n  });\n  const handleEnd = (runId) => __async(this, null, function* () {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      yield writer.ready;\n      yield writer.close();\n    }\n  });\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)),\n    handlers: {\n      handleLLMNewToken: (token) => __async(this, null, function* () {\n        yield writer.ready;\n        yield writer.write(token);\n      }),\n      handleLLMStart: (_llm, _prompts, runId) => __async(this, null, function* () {\n        handleStart(runId);\n      }),\n      handleLLMEnd: (_output, runId) => __async(this, null, function* () {\n        yield handleEnd(runId);\n      }),\n      handleLLMError: (e, runId) => __async(this, null, function* () {\n        yield handleError(e, runId);\n      }),\n      handleChainStart: (_chain, _inputs, runId) => __async(this, null, function* () {\n        handleStart(runId);\n      }),\n      handleChainEnd: (_outputs, runId) => __async(this, null, function* () {\n        yield handleEnd(runId);\n      }),\n      handleChainError: (e, runId) => __async(this, null, function* () {\n        yield handleError(e, runId);\n      }),\n      handleToolStart: (_tool, _input, runId) => __async(this, null, function* () {\n        handleStart(runId);\n      }),\n      handleToolEnd: (_output, runId) => __async(this, null, function* () {\n        yield handleEnd(runId);\n      }),\n      handleToolError: (e, runId) => __async(this, null, function* () {\n        yield handleError(e, runId);\n      })\n    }\n  };\n}\n\n// shared/utils.ts\nimport { customAlphabet } from \"nanoid/non-secure\";\nvar nanoid = customAlphabet(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7\n);\nfunction createChunkDecoder() {\n  const decoder = new TextDecoder();\n  return function(chunk) {\n    if (!chunk)\n      return \"\";\n    return decoder.decode(chunk, { stream: true });\n  };\n}\nexport {\n  AIStream,\n  AnthropicStream,\n  CohereStream,\n  HuggingFaceStream,\n  LangChainStream,\n  OpenAIStream,\n  StreamingTextResponse,\n  createCallbacksTransformer,\n  createChunkDecoder,\n  createEventStreamTransformer,\n  nanoid,\n  streamToResponse,\n  trimStartOfStreamHelper\n};\n"],
  "mappings": "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",
  "names": ["createParser", "onParse", "isFirstChunk", "buffer", "startingPosition", "startingFieldLength", "eventId", "eventName", "data", "reset", "feed", "chunk", "hasBom", "slice", "BOM", "length", "position", "discardTrailingNewline", "lineLength", "fieldLength", "character", "index", "parseEventStreamLine", "lineBuffer", "type", "id", "event", "noValue", "field", "step", "valueLength", "value", "toString", "includes", "retry", "parseInt", "Number", "isNaN", "every", "charCode", "charCodeAt"]
}
